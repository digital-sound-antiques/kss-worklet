/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"abort\": () => (/* binding */ abort),\n/* harmony export */   \"analyser\": () => (/* binding */ analyser),\n/* harmony export */   \"audioContext\": () => (/* binding */ audioContext),\n/* harmony export */   \"fwd\": () => (/* binding */ fwd),\n/* harmony export */   \"load\": () => (/* binding */ load),\n/* harmony export */   \"main\": () => (/* binding */ main),\n/* harmony export */   \"next\": () => (/* binding */ next),\n/* harmony export */   \"pause\": () => (/* binding */ pause),\n/* harmony export */   \"play\": () => (/* binding */ play),\n/* harmony export */   \"prev\": () => (/* binding */ prev),\n/* harmony export */   \"replay\": () => (/* binding */ replay),\n/* harmony export */   \"resume\": () => (/* binding */ resume),\n/* harmony export */   \"resumeAudioContext\": () => (/* binding */ resumeAudioContext),\n/* harmony export */   \"rev\": () => (/* binding */ rev)\n/* harmony export */ });\n/* harmony import */ var _kss_player_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./kss-player.js */ \"./src/kss-player.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nlet player;\nconst audioContext = new AudioContext({ sampleRate: 44100 });\nconst analyser = audioContext.createAnalyser();\n(() => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        player = new _kss_player_js__WEBPACK_IMPORTED_MODULE_0__.KSSPlayer('worklet');\n        player.connect(analyser);\n        analyser.connect(audioContext.destination);\n        analyser.fftSize = 256;\n        // Note: A secure connection is required to update a global variable from a module.\n    }\n    catch (e) {\n        console.error(e);\n        // Safari does not output an error to the console when it is thrown in a module script.\n        throw e;\n    }\n}))();\nconst dataBuf = new Uint8Array(analyser.fftSize / 2);\nconst waveBuf = new Float32Array(analyser.fftSize);\nfunction renderAnalyzer() {\n    requestAnimationFrame(renderAnalyzer);\n    if (player.state == 'playing') {\n        const canvas = document.getElementById('analyser');\n        const width = canvas.width;\n        const height = canvas.height;\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, width, height);\n        analyser.getByteFrequencyData(dataBuf); //Spectrum Data\n        ctx.fillStyle = '#0080ff';\n        for (let i = 0; i < width; i += 4) {\n            const h = dataBuf[Math.floor(i * dataBuf.length / width)];\n            ctx.fillRect(i, height - h, 3, h);\n        }\n        analyser.getFloatTimeDomainData(waveBuf);\n        ctx.lineWidth = 2;\n        ctx.fillStyle = 'none';\n        ctx.strokeStyle = '#ff0000';\n        ctx.beginPath();\n        ctx.moveTo(0, height / 2);\n        const sliceWidth = width / waveBuf.length;\n        let x = 0;\n        for (let i = 0; i < waveBuf.length; i++) {\n            const y = height / 2 + waveBuf[i] * 400;\n            if (i == 0) {\n                ctx.moveTo(x, y);\n            }\n            else {\n                ctx.lineTo(x, y);\n            }\n            x += sliceWidth;\n        }\n        ctx.lineTo(width, height / 2);\n        ctx.stroke();\n    }\n}\nfunction createListItem({ name, url }) {\n    const node = document.getElementById('list-item-template').content.cloneNode(true);\n    const title = node.querySelector('.title');\n    title.innerText = name;\n    const listItem = node.querySelector('.list-item');\n    listItem.dataset.url = url;\n    listItem.addEventListener('click', () => playItem(listItem));\n    return node;\n}\nfunction buildMenu() {\n    const mmlRoot = 'https://raw.githubusercontent.com/mmlbox/';\n    const items = [];\n    for (let i = 1; i <= 17; i++) {\n        const id = i < 10 ? `0${i}` : `${i}`;\n        items.push({ name: `HYDLIDE3_${id}`, url: `${mmlRoot}hyd2413/main/fm_psg/mgs/hyd3_${id}.mgs` });\n    }\n    for (let i = 1; i <= 29; i++) {\n        const id = i < 10 ? `0${i}` : `${i}`;\n        items.push({ name: `YS1_${id}`, url: `${mmlRoot}ys2413/main/fm_psg/mgs/ys1ex_${id}.mgs` });\n    }\n    for (let i = 0; i <= 30; i++) {\n        const id = i < 10 ? `0${i}` : `${i}`;\n        items.push({ name: `YS2_${id}`, url: `${mmlRoot}ys2413/main/fm_psg/mgs/ys2ex_${id}.mgs` });\n    }\n    for (let i = 0; i <= 59; i++) {\n        const id = i < 10 ? `00${i}` : `0${i}`;\n        items.push({ name: `SOR_${id}`, url: `${mmlRoot}sor2413/main/fm_psg/mgs/en/soe${id}.mgs` });\n    }\n    const list = document.getElementById('mgs-list');\n    for (const item of items) {\n        list.appendChild(createListItem(item));\n    }\n}\nfunction main() {\n    renderAnalyzer();\n    document.addEventListener(\"visibilitychange\", () => {\n        if (document.visibilityState === \"visible\" && audioContext.state == 'interrupted') {\n            /* unawaited */ audioContext.resume();\n        }\n    });\n    document.getElementById('pause').classList.add('hidden');\n    const typeSelector = document.getElementById('processorType');\n    typeSelector.onchange = (ev) => {\n        player.changeRendererType(ev.target.value);\n    };\n    const slider = document.getElementById('slider');\n    slider.addEventListener('input', () => {\n        console.log('input');\n        sliderDragging = true;\n    });\n    slider.addEventListener('change', () => {\n        console.log('change');\n        sliderDragging = false;\n        player.seekInFrame(parseInt(slider.value));\n    });\n    buildMenu();\n    installDragStage();\n}\nlet selectedUrl;\nlet kss;\nlet sliderDragging = false;\nfunction playItem(item) {\n    if (item instanceof HTMLElement && item.classList.contains('list-item')) {\n        document.querySelectorAll('.list-item').forEach((el) => el.classList.remove('selected'));\n        item.classList.add('selected');\n        const url = item.dataset.url;\n        selectedUrl = url;\n        play();\n    }\n}\nfunction load(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const res = yield fetch(url);\n        kss = yield res.arrayBuffer();\n    });\n}\nfunction resumeAudioContext() {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield audioContext.resume();\n    });\n}\nfunction replay() {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield player.seekInTime(0);\n    });\n}\nfunction play() {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield resumeAudioContext();\n        yield load(selectedUrl);\n        if (kss == null) {\n            return;\n        }\n        player.onstatechange = (state) => {\n            if (state == 'playing') {\n                document.getElementById('play').classList.add('hidden');\n                document.getElementById('pause').classList.remove('hidden');\n            }\n            else {\n                document.getElementById('play').classList.remove('hidden');\n                document.getElementById('pause').classList.add('hidden');\n            }\n            if (state == 'stopped') {\n                next();\n            }\n        };\n        player.onprogress = (data) => {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n            document.getElementById('decoder').innerText = `${(_a = data.decoder) === null || _a === void 0 ? void 0 : _a.decodeFrames} ${(_c = (_b = data.decoder) === null || _b === void 0 ? void 0 : _b.decodeSpeed) === null || _c === void 0 ? void 0 : _c.toFixed(2)}x ${((_d = data.decoder) === null || _d === void 0 ? void 0 : _d.isDecoding) ? '' : '*'}`;\n            document.getElementById('renderer').innerText = `${(_e = data.renderer) === null || _e === void 0 ? void 0 : _e.currentTime}/${(_f = data.renderer) === null || _f === void 0 ? void 0 : _f.bufferedTime} ${(_g = data.renderer) === null || _g === void 0 ? void 0 : _g.currentFrame}/${(_h = data.renderer) === null || _h === void 0 ? void 0 : _h.bufferedFrames}${((_j = data.renderer) === null || _j === void 0 ? void 0 : _j.isFulFilled) ? '*' : ''}`;\n            if (data.renderer != null) {\n                const slider = document.getElementById('slider');\n                slider.max = `${data.renderer.bufferedFrames}`;\n                if (!sliderDragging) {\n                    slider.value = `${data.renderer.currentFrame}`;\n                }\n            }\n        };\n        return player.play({ data: kss });\n    });\n}\nfunction rev() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return player.seekInTime(-10000, true);\n    });\n}\nfunction fwd() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return player.seekInTime(10000, true);\n    });\n}\nfunction pause() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return player.pause();\n    });\n}\nfunction resume() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return player.resume();\n    });\n}\nfunction abort() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield player.abort();\n    });\n}\nfunction next() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const item = document.querySelector('.list-item.selected');\n        if (item instanceof HTMLElement) {\n            playItem(item.nextElementSibling);\n        }\n    });\n}\nfunction prev() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const item = document.querySelector('.list-item.selected');\n        if (item instanceof HTMLElement) {\n            playItem(item.previousElementSibling);\n        }\n    });\n}\nfunction installDragStage() {\n    // const elem = document.body;\n    // elem.addEventListener(\"dragover\", onDragOver);\n    // elem.addEventListener(\"dragenter\", onDragEnter);\n    // elem.addEventListener(\"dragleave\", onDragLeave);\n    // elem.addEventListener(\"drop\", onDrop);\n    const playerFrame = document.getElementById('player-frame');\n    playerFrame.addEventListener('dragenter', (e) => {\n        e.preventDefault();\n    });\n    playerFrame.addEventListener('dragover', (e) => {\n        var _a;\n        const listItem = (_a = e.target) === null || _a === void 0 ? void 0 : _a.closest('.list-item');\n        if (listItem instanceof HTMLElement) {\n            listItem.classList.add('drop-focus');\n            e.dataTransfer.dropEffect = 'copy';\n        }\n        else {\n            playerFrame.style.border = 'red 2px solid';\n            e.dataTransfer.dropEffect = 'move';\n        }\n        e.preventDefault();\n    });\n    playerFrame.addEventListener('dragleave', (e) => {\n        var _a;\n        const listItem = (_a = e.target) === null || _a === void 0 ? void 0 : _a.closest('.list-item');\n        if (listItem instanceof HTMLElement) {\n            listItem.classList.remove('drop-focus');\n        }\n        else {\n            playerFrame.style.border = 'none';\n        }\n    });\n    playerFrame.addEventListener('drop', (e) => {\n        playerFrame.style.border = 'none';\n        onDrop(e);\n    });\n}\nfunction onDrop(e) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        console.log(e.target);\n        e.preventDefault();\n        const insertBefore = (_a = e.target) === null || _a === void 0 ? void 0 : _a.closest('.list-item');\n        if (insertBefore) {\n            insertBefore.classList.remove('drop-focus');\n        }\n        return loadFiles(e.dataTransfer.files, insertBefore);\n    });\n}\nfunction loadFiles(files, insertBefore) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const items = [];\n        for (const file of files) {\n            try {\n                const u8 = yield loadFromFile(file);\n                const base64EncodedData = btoa(String.fromCharCode.apply(null, u8));\n                const mimeType = 'application/octet-binary';\n                const dataURI = `data:${mimeType};base64,${base64EncodedData}`;\n                items.push(createListItem({ name: file.name, url: dataURI }));\n            }\n            catch (e) {\n                console.warn(e);\n            }\n        }\n        if (items.length > 0) {\n            const list = document.getElementById('mgs-list');\n            if (insertBefore != null) {\n                for (const item of items) {\n                    list.insertBefore(item, insertBefore);\n                }\n            }\n            else {\n                list.innerText = '';\n                const target = items[0].querySelector('.list-item');\n                for (const item of items) {\n                    list.appendChild(item);\n                }\n                playItem(target);\n            }\n        }\n    });\n}\nfunction loadFromFile(blob) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onloadend = () => {\n                try {\n                    const u = new Uint8Array(reader.result);\n                    let version = 6 < u.length ? String.fromCharCode(u[0], u[1], u[2], u[3], u[4], u[5]) : null;\n                    if (version && version.indexOf(\"MGS\") === 0) {\n                        resolve(u);\n                        return;\n                    }\n                    throw new Error('Not a MGS file');\n                }\n                catch (e) {\n                    reject(e);\n                }\n            };\n            reader.readAsArrayBuffer(blob);\n        });\n    });\n}\n\n\n//# sourceURL=webpack://kss-worklet/./src/index.ts?");

/***/ }),

/***/ "./src/kss-player.ts":
/*!***************************!*\
  !*** ./src/kss-player.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"KSSPlayer\": () => (/* binding */ KSSPlayer)\n/* harmony export */ });\n/* harmony import */ var worker_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! worker-url */ \"./node_modules/worker-url/index.js\");\n/* harmony import */ var webaudio_stream_player__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! webaudio-stream-player */ \"./node_modules/webaudio-stream-player/dist/index.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n// The `name` option of WorkerUrl is a marker to determine the webpack's chunkname (i.e. output filename).\n// Do not use variable to specify the name - It must be written as an immediate string.\nconst decoderUrl = new worker_url__WEBPACK_IMPORTED_MODULE_0__.WorkerUrl(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"kss-decorder\"), __webpack_require__.b), { name: 'kss-decorder', type: \"module\" });\nconst workletUrl = new worker_url__WEBPACK_IMPORTED_MODULE_0__.WorkerUrl(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"renderer\"), __webpack_require__.b), { name: 'renderer', type: \"module\" });\nclass KSSPlayer extends webaudio_stream_player__WEBPACK_IMPORTED_MODULE_1__.AudioPlayer {\n    constructor(rendererType) {\n        super({\n            rendererType: rendererType,\n            decoderWorkerUrl: decoderUrl,\n            rendererWorkletUrl: workletUrl,\n            rendererWorkletName: 'renderer',\n            recycleDecoder: true,\n            numberOfChannels: 1,\n        });\n    }\n    play(args) {\n        const _super = Object.create(null, {\n            play: { get: () => super.play }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            _super.play.call(this, args);\n        });\n    }\n}\n\n\n//# sourceURL=webpack://kss-worklet/./src/kss-player.ts?");

/***/ }),

/***/ "./node_modules/worker-url/index.js":
/*!******************************************!*\
  !*** ./node_modules/worker-url/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WorkerUrl\": () => (/* binding */ WorkerUrl)\n/* harmony export */ });\nfunction WorkerUrl(url, options) {\n\tif (!options) return url;\n\tconst { customPath } = options;\n\tif (!customPath) return url;\n\treturn customPath();\n}\n\n\n//# sourceURL=webpack://kss-worklet/./node_modules/worker-url/index.js?");

/***/ }),

/***/ "./node_modules/webaudio-stream-player/dist/audio-decoder.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webaudio-stream-player/dist/audio-decoder.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioDecoder\": () => (/* binding */ AudioDecoder)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass AudioDecoder {\n    constructor(worker) {\n        this._seq = 0;\n        this.onprogress = null;\n        this._completerMap = {};\n        this._worker = worker;\n        this._worker.onmessage = (ev) => this._handleMessage(ev);\n    }\n    _handleMessage(ev) {\n        var _a, _b;\n        if (((_a = ev.data) === null || _a === void 0 ? void 0 : _a.type) == 'progress') {\n            if (this.onprogress != null) {\n                this.onprogress(ev.data.data);\n            }\n            return;\n        }\n        const seq = (_b = ev.data) === null || _b === void 0 ? void 0 : _b.seq;\n        if (seq != null) {\n            const completer = this._completerMap[seq];\n            delete this._completerMap[seq];\n            completer(ev.data);\n        }\n    }\n    _request(req, transfer = []) {\n        var _a;\n        const seq = this._seq++;\n        const ts = Date.now();\n        (_a = this._worker) === null || _a === void 0 ? void 0 : _a.postMessage(Object.assign({ seq, ts }, req), transfer);\n        const ts2 = Date.now();\n        // console.log(`DecoderController req ${req.type}@${seq} ${ts2 - ts}ms`);\n        return new Promise((resolve, reject) => {\n            this._completerMap[seq] = (e) => {\n                const elapsed = Date.now() - ts2;\n                // console.log(`DecoderController res ${e.type}@${e.seq} ${elapsed}ms`);\n                if (e.error == null) {\n                    resolve(e.data);\n                }\n                else {\n                    reject(e.error);\n                }\n            };\n        });\n    }\n    init(sampleRate, numberOfChannels) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._request({ type: 'init', args: { sampleRate, numberOfChannels } });\n        });\n    }\n    start(outputPort, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._request({ type: 'start', outputPort, args }, [outputPort]);\n        });\n    }\n    abort() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._request({ type: 'abort' });\n        });\n    }\n    terminate() {\n        var _a;\n        (_a = this._worker) === null || _a === void 0 ? void 0 : _a.terminate();\n        this._worker = null;\n    }\n}\n\n\n//# sourceURL=webpack://kss-worklet/./node_modules/webaudio-stream-player/dist/audio-decoder.js?");

/***/ }),

/***/ "./node_modules/webaudio-stream-player/dist/audio-player.js":
/*!******************************************************************!*\
  !*** ./node_modules/webaudio-stream-player/dist/audio-player.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioPlayer\": () => (/* binding */ AudioPlayer)\n/* harmony export */ });\n/* harmony import */ var _audio_decoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audio-decoder.js */ \"./node_modules/webaudio-stream-player/dist/audio-decoder.js\");\n/* harmony import */ var _audio_renderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audio-renderer.js */ \"./node_modules/webaudio-stream-player/dist/audio-renderer.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass AudioPlayer {\n    constructor(args) {\n        var _a;\n        this._decoder = null;\n        this._renderer = null;\n        this._audioContext = null;\n        this._destination = null;\n        this._state = 'initial';\n        this._progress = {};\n        this.onstatechange = null;\n        this.onprogress = null;\n        this._rendererType = args.rendererType;\n        this._decoderUrl = args.decoderWorkerUrl;\n        this._rendererWorkletUrl = args.rendererWorkletUrl;\n        this._rendererWorkletName = args.rendererWorkletName;\n        this._recycleDecoder = (_a = args.recycleDecoder) !== null && _a !== void 0 ? _a : false;\n        this._numberOfChannels = args.numberOfChannels;\n    }\n    get numberOfChannels() { return this._numberOfChannels; }\n    changeRendererType(type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._rendererType != type) {\n                yield this.dispose();\n                this._rendererType = type;\n            }\n        });\n    }\n    get state() { return this._state; }\n    get progress() { return this._progress; }\n    connect(destination) {\n        if (!(destination.context instanceof AudioContext)) {\n            throw new Error('destination is not attached to an AudioContext.');\n        }\n        this._destination = destination;\n    }\n    disconnect() {\n        this._destination = null;\n        return this.dispose();\n    }\n    _attachContext(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._audioContext != context) {\n                if (this._audioContext != null) {\n                    yield this.dispose();\n                }\n                this._audioContext = context;\n                if (this._rendererType == 'worklet') {\n                    yield this._audioContext.audioWorklet.addModule(this._rendererWorkletUrl);\n                }\n            }\n        });\n    }\n    play(args) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            this._progress = {};\n            const mch = new MessageChannel();\n            yield this._attachContext(this._destination.context);\n            if (((_a = this._audioContext) === null || _a === void 0 ? void 0 : _a.state) == 'suspended') {\n                throw new Error('AudioContext is suspended. `await AudioContext.resume()` in advance within the call stack of a UI event handler.');\n            }\n            if (this._decoder == null) {\n                this._decoder = new _audio_decoder_js__WEBPACK_IMPORTED_MODULE_0__.AudioDecoder(new Worker(this._decoderUrl));\n                yield this._decoder.init(this._audioContext.sampleRate, this._numberOfChannels);\n            }\n            else {\n                yield this._decoder.abort();\n            }\n            yield this._decoder.start(mch.port2, args);\n            (_b = this._renderer) !== null && _b !== void 0 ? _b : (this._renderer = _audio_renderer_js__WEBPACK_IMPORTED_MODULE_1__.AudioRenderer.create(this._rendererType, this._audioContext, this._numberOfChannels, this._rendererWorkletName));\n            this._renderer.connect(this._destination);\n            this._renderer.onstatechange = (ev) => {\n                this._state = ev;\n                if (this.onstatechange != null) {\n                    this.onstatechange(ev);\n                }\n            };\n            this._decoder.onprogress = (data) => {\n                this._progress.decoder = data;\n                if (this.onprogress != null) {\n                    this.onprogress(this._progress);\n                }\n            };\n            this._renderer.onprogress = (data) => {\n                this._progress.renderer = data;\n                if (this.onprogress != null) {\n                    this.onprogress(this._progress);\n                }\n            };\n            yield this._renderer.play(mch.port1);\n        });\n    }\n    seekInFrame(frame, relative = false) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state != 'initial' && this._state != 'aborted') {\n                yield ((_a = this._renderer) === null || _a === void 0 ? void 0 : _a.seek(frame, relative));\n            }\n        });\n    }\n    seekInTime(time, relative = false) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state != 'initial' && this._state != 'aborted') {\n                const pos = Math.floor(this._audioContext.sampleRate / 1000 * time);\n                yield ((_a = this._renderer) === null || _a === void 0 ? void 0 : _a.seek(pos, relative));\n            }\n        });\n    }\n    togglePause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'playing') {\n                return this.pause();\n            }\n            if (this._state == 'paused') {\n                return this.resume();\n            }\n        });\n    }\n    pause() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield ((_a = this._renderer) === null || _a === void 0 ? void 0 : _a.pause());\n        });\n    }\n    resume() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield ((_a = this._renderer) === null || _a === void 0 ? void 0 : _a.resume());\n        });\n    }\n    abort() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._decoder != null) {\n                yield this._decoder.abort();\n                this._decoder.onprogress = null;\n                if (!this._recycleDecoder) {\n                    this._decoder.terminate();\n                    this._decoder = null;\n                }\n            }\n            if (this._renderer != null) {\n                this._renderer.disconnect();\n                this._renderer.onprogress = null;\n                yield this._renderer.abort();\n            }\n        });\n    }\n    dispose() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._decoder != null) {\n                yield ((_a = this._decoder) === null || _a === void 0 ? void 0 : _a.abort());\n                this._decoder.onprogress = null;\n                this._decoder.terminate();\n                this._decoder = null;\n            }\n            if (this._renderer != null) {\n                this._renderer.disconnect();\n                this._renderer.onprogress = null;\n                this._renderer.onstatechange = null;\n                yield this._renderer.dispose();\n                this._renderer = null;\n            }\n            this._audioContext = null;\n        });\n    }\n}\n\n\n//# sourceURL=webpack://kss-worklet/./node_modules/webaudio-stream-player/dist/audio-player.js?");

/***/ }),

/***/ "./node_modules/webaudio-stream-player/dist/audio-renderer.js":
/*!********************************************************************!*\
  !*** ./node_modules/webaudio-stream-player/dist/audio-renderer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioRenderer\": () => (/* binding */ AudioRenderer)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/webaudio-stream-player/dist/utils.js\");\n/* harmony import */ var _wave_buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wave-buffer.js */ \"./node_modules/webaudio-stream-player/dist/wave-buffer.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass AudioRenderer {\n    constructor(delegate) {\n        this._delegate = delegate;\n    }\n    static create(type, context, numberOfChannels, workletName) {\n        if (type == 'worklet') {\n            if (workletName == null) {\n                throw new Error(`workletName must be specified.`);\n            }\n            return new AudioRenderer(new WorkletRenderer(context, numberOfChannels, workletName));\n        }\n        else if (type == 'script') {\n            return new AudioRenderer(new ScriptRenderer(context, numberOfChannels));\n        }\n        else {\n            throw new Error(`Unspported renderer type: ${type}`);\n        }\n    }\n    get state() { return this._delegate.state; }\n    ;\n    get onprogress() { return this._delegate.onprogress; }\n    set onprogress(f) { this._delegate.onprogress = f; }\n    get onstatechange() { return this._delegate.onstatechange; }\n    set onstatechange(f) { this._delegate.onstatechange = f; }\n    connect(destination) { return this._delegate.connect(destination); }\n    disconnect() { return this._delegate.disconnect(); }\n    play(input) { return this._delegate.play(input); }\n    seek(pos, relative = false) { return this._delegate.seek(pos, relative); }\n    pause() { return this._delegate.pause(); }\n    resume() { return this._delegate.resume(); }\n    abort() { return this._delegate.abort(); }\n    dispose() { return this._delegate.dispose(); }\n}\nclass WorkletRenderer {\n    constructor(audioContext, numberOfChannels, workletName) {\n        this._state = 'initial';\n        this._seq = 0;\n        this._completerMap = {};\n        this.onprogress = null;\n        this.onstatechange = null;\n        this._node = new AudioWorkletNode(audioContext, workletName, {\n            numberOfInputs: 0,\n            numberOfOutputs: 1,\n            outputChannelCount: [numberOfChannels],\n            // parameterData: null,\n            // processorOptions: null,\n        });\n        this._numberOfChannels = numberOfChannels;\n        this._node.port.onmessage = (ev) => this._handleMessage(ev);\n    }\n    get numberOfChannels() { return this._numberOfChannels; }\n    setState(newState) {\n        if (this._state != newState) {\n            this._state = newState;\n            if (this.onstatechange) {\n                this.onstatechange(this._state);\n            }\n        }\n    }\n    get state() { return this._state; }\n    _handleMessage(ev) {\n        var _a, _b, _c;\n        switch ((_a = ev.data) === null || _a === void 0 ? void 0 : _a.type) {\n            case 'progress':\n                if (this.onprogress != null) {\n                    this.onprogress(Object.assign({}, ev.data.stat));\n                }\n                break;\n            case 'state':\n                this.setState((_b = ev.data) === null || _b === void 0 ? void 0 : _b.state);\n                break;\n        }\n        const seq = (_c = ev.data) === null || _c === void 0 ? void 0 : _c.seq;\n        if (seq != null) {\n            const completer = this._completerMap[seq];\n            delete this._completerMap[seq];\n            completer(ev.data);\n        }\n    }\n    _request(req, transfer = []) {\n        const seq = this._seq++;\n        this._node.port.postMessage(Object.assign({ seq }, req), transfer);\n        // const start = Date.now();\n        return new Promise((resolve, reject) => {\n            this._completerMap[seq] = (e) => {\n                // const elapsed = Date.now() - start;\n                // console.log(`WorkletController[${e.seq}]:${e.type} ${elapsed}ms`);\n                if (e.error == null) {\n                    resolve(e.data);\n                }\n                else {\n                    reject(e.error);\n                }\n            };\n        });\n    }\n    connect(destination) { this._node.connect(destination); }\n    disconnect() { this._node.disconnect(); }\n    play(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'playing' || this._state == 'paused') {\n                yield this._request({ type: 'abort' });\n            }\n            const res = yield this._request({ type: 'play', inputPort: input }, [input]);\n            this.setState('playing');\n        });\n    }\n    seek(pos, relative) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._request({ type: 'seek', seekPos: pos, relative });\n        });\n    }\n    pause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'playing') {\n                const res = yield this._request({ type: 'pause' });\n                this.setState('paused');\n            }\n        });\n    }\n    resume() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'paused') {\n                const res = yield this._request({ type: 'resume' });\n                this.setState('playing');\n            }\n        });\n    }\n    abort() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state != 'stopped' && this._state != 'aborted') {\n                const res = yield this._request({ type: 'abort' });\n                this.setState('aborted');\n            }\n        });\n    }\n    dispose() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._request({ type: 'dispose' });\n            this.setState('disposed');\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.isChrome) {\n                console.warn(`StreamerWorkletController.dispose: This operation may cause memory-leak on Chrome since Chrome will not release the AudioWorklet after the tied AudioContext is closed. See: https://bugs.chromium.org/p/chromium/issues/detail?id=1298955`);\n            }\n        });\n    }\n    ;\n}\nclass ScriptRenderer {\n    constructor(audioContext, numberOfChannels) {\n        this._inputPort = null;\n        this._state = 'initial';\n        this.onprogress = null;\n        this.onstatechange = null;\n        this._node = audioContext.createScriptProcessor(1024, 0, numberOfChannels);\n        this._node.onaudioprocess = (ev) => this._onAudioProcess(ev);\n        this._buffer = new _wave_buffer_js__WEBPACK_IMPORTED_MODULE_1__.WaveBuffer(audioContext.sampleRate, numberOfChannels);\n        this._numberOfChannels = numberOfChannels;\n    }\n    get numberOfChannels() { return this._numberOfChannels; }\n    get state() { return this._state; }\n    setState(newState) {\n        if (this._state != newState) {\n            this._state = newState;\n            if (this.onstatechange != null) {\n                this.onstatechange(this._state);\n            }\n        }\n    }\n    connect(destination) { this._node.connect(destination); }\n    disconnect() { this._node.disconnect(); }\n    play(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._inputPort != null) {\n                this._inputPort.onmessage = null;\n                this._inputPort.close();\n            }\n            this._inputPort = input;\n            this._inputPort.onmessage = (ev) => this._buffer.write(ev.data);\n            this._buffer.clear();\n            this.setState('playing');\n        });\n    }\n    seek(pos, relative) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._buffer.seekTo(pos, relative);\n        });\n    }\n    pause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'playing') {\n                this.setState('paused');\n            }\n        });\n    }\n    resume() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'paused') {\n                this.setState('playing');\n            }\n        });\n    }\n    abort() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'playing' || this._state == 'paused') {\n                this._buffer.clear();\n                this.setState('aborted');\n            }\n        });\n    }\n    _onAudioProcess(ev) {\n        if (this._state == 'playing') {\n            const res = this._buffer.onAudioProcess(ev);\n            if (this.onprogress != null) {\n                const stat = this._buffer.stat;\n                this.onprogress(this._buffer.stat);\n            }\n            if (!res) {\n                this._buffer.clear();\n                this.setState('stopped');\n            }\n        }\n    }\n    dispose() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._buffer.clear();\n            if (this._inputPort != null) {\n                this._inputPort.onmessage = null;\n                this._inputPort.close();\n                this._inputPort = null;\n            }\n            this._node.onaudioprocess = null;\n            this.setState('disposed');\n        });\n    }\n}\n\n\n//# sourceURL=webpack://kss-worklet/./node_modules/webaudio-stream-player/dist/audio-renderer.js?");

/***/ }),

/***/ "./node_modules/webaudio-stream-player/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/webaudio-stream-player/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioDecoder\": () => (/* reexport safe */ _audio_decoder_js__WEBPACK_IMPORTED_MODULE_1__.AudioDecoder),\n/* harmony export */   \"AudioDecoderWorker\": () => (/* reexport safe */ _workers_audio_decoder_worker_js__WEBPACK_IMPORTED_MODULE_3__.AudioDecoderWorker),\n/* harmony export */   \"AudioPlayer\": () => (/* reexport safe */ _audio_player_js__WEBPACK_IMPORTED_MODULE_0__.AudioPlayer),\n/* harmony export */   \"AudioRenderer\": () => (/* reexport safe */ _audio_renderer_js__WEBPACK_IMPORTED_MODULE_2__.AudioRenderer)\n/* harmony export */ });\n/* harmony import */ var _audio_player_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audio-player.js */ \"./node_modules/webaudio-stream-player/dist/audio-player.js\");\n/* harmony import */ var _audio_decoder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audio-decoder.js */ \"./node_modules/webaudio-stream-player/dist/audio-decoder.js\");\n/* harmony import */ var _audio_renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./audio-renderer.js */ \"./node_modules/webaudio-stream-player/dist/audio-renderer.js\");\n/* harmony import */ var _workers_audio_decoder_worker_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./workers/audio-decoder-worker.js */ \"./node_modules/webaudio-stream-player/dist/workers/audio-decoder-worker.js\");\n\n\n\n\n// DO NOT EXPORT from './workers/audio-renderer-worklet-processor.js';\n// If export, webpack bundles this into the main GlobalScope, not AudioWorkletGlobalScope.\n\n\n//# sourceURL=webpack://kss-worklet/./node_modules/webaudio-stream-player/dist/index.js?");

/***/ }),

/***/ "./node_modules/webaudio-stream-player/dist/utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/webaudio-stream-player/dist/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isChrome\": () => (/* binding */ isChrome),\n/* harmony export */   \"isSafari\": () => (/* binding */ isSafari)\n/* harmony export */ });\nconst isSafari = (() => {\n    const maybeSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    if (maybeSafari) {\n        if (/google/i.test(navigator.vendor)) {\n            // A fake Safari that may be a mobile simulator on Chrome.\n            return false;\n        }\n        return true;\n    }\n    return false;\n})();\nconst isChrome = (() => {\n    var _a;\n    const uad = navigator.userAgentData;\n    if (uad && ((_a = uad === null || uad === void 0 ? void 0 : uad.brands[0]) === null || _a === void 0 ? void 0 : _a.brand) == 'Google Chrome') {\n        return true;\n    }\n    return false;\n})();\n\n\n//# sourceURL=webpack://kss-worklet/./node_modules/webaudio-stream-player/dist/utils.js?");

/***/ }),

/***/ "./node_modules/webaudio-stream-player/dist/wave-buffer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/webaudio-stream-player/dist/wave-buffer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WaveBuffer\": () => (/* binding */ WaveBuffer)\n/* harmony export */ });\nfunction createSameTypeBuffer(prot, length) {\n    if (prot instanceof Float32Array) {\n        return new Float32Array(length);\n    }\n    else if (prot instanceof Int32Array) {\n        return new Int32Array(length);\n    }\n    else if (prot instanceof Int16Array) {\n        return new Int16Array(length);\n    }\n    else if (prot instanceof Int8Array) {\n        return new Int8Array(length);\n    }\n    else if (prot instanceof Uint8Array) {\n        return new Uint8Array(length);\n    }\n    else {\n        throw new Error(`Unsupported array type ${typeof prot}`);\n    }\n}\nclass MonoWaveBuffer {\n    constructor(initialLength) {\n        this._wave = null;\n        this.rp = 0;\n        this.wp = 0;\n        this._initialLength = initialLength;\n    }\n    get byteLength() {\n        if (this._wave != null) {\n            return this.wp * this._wave.BYTES_PER_ELEMENT;\n        }\n        return 0;\n    }\n    seekTo(frame, relative) {\n        if (relative) {\n            this.rp += frame;\n        }\n        else {\n            this.rp = frame;\n        }\n        this.rp = Math.min(Math.max(0, this.rp), this.wp);\n    }\n    clear() {\n        this._wave = null;\n        this.wp = 0;\n        this.rp = 0;\n    }\n    write(data) {\n        if (this._wave == null) {\n            this._wave = createSameTypeBuffer(data, this._initialLength);\n        }\n        if (typeof data != typeof this._wave) {\n            throw new Error(`The type of wave sample has changed during playing from ${typeof this._wave} to ${typeof data}.`);\n        }\n        if (this.wp + data.length > this._wave.length) {\n            const newWave = createSameTypeBuffer(this._wave, this._wave.length * 2);\n            newWave.set(this._wave);\n            this._wave = newWave;\n        }\n        this._wave.set(data, this.wp);\n        this.wp += data.length;\n    }\n    process(output) {\n        if (this._wave instanceof Float32Array) {\n            for (let i = 0; i < output.length; i++) {\n                if (this.rp < this.wp) {\n                    output[i] = this._wave[this.rp++];\n                }\n            }\n        }\n        else if (this._wave instanceof Int32Array) {\n            for (let i = 0; i < output.length; i++) {\n                if (this.rp < this.wp) {\n                    output[i] = this._wave[this.rp++] / (1 << 31);\n                }\n            }\n        }\n        else if (this._wave instanceof Int16Array) {\n            for (let i = 0; i < output.length; i++) {\n                if (this.rp < this.wp) {\n                    output[i] = this._wave[this.rp++] / (1 << 15);\n                }\n            }\n        }\n        else if (this._wave instanceof Int8Array) {\n            for (let i = 0; i < output.length; i++) {\n                if (this.rp < this.wp) {\n                    output[i] = this._wave[this.rp++] / (1 << 7);\n                }\n            }\n        }\n        else if (this._wave instanceof Uint8Array) {\n            for (let i = 0; i < output.length; i++) {\n                if (this.rp < this.wp) {\n                    output[i] = (this._wave[this.rp++] - 128) / (1 << 7);\n                }\n            }\n        }\n        else {\n            // do nothing\n        }\n    }\n}\nclass WaveBuffer {\n    constructor(sampleRate, numberOfChannels) {\n        this.isFulFilled = false;\n        this._sampleRate = sampleRate;\n        this._waves = Array();\n        for (let i = 0; i < numberOfChannels; i++) {\n            this._waves.push(new MonoWaveBuffer(sampleRate * 60));\n        }\n    }\n    seekTo(frame, relative) {\n        for (const wave of this._waves) {\n            wave.seekTo(frame, relative);\n        }\n    }\n    clear() {\n        for (const wave of this._waves) {\n            wave.clear();\n        }\n    }\n    get stat() {\n        const currentFrame = this._waves[0].rp;\n        const bufferedFrames = this._waves[0].wp;\n        return {\n            currentFrame,\n            currentTime: Math.floor(currentFrame / this._sampleRate * 1000),\n            bufferedFrames,\n            bufferedTime: Math.floor(bufferedFrames / this._sampleRate * 1000),\n            isFulFilled: this.isFulFilled,\n        };\n    }\n    write(inputs) {\n        if (inputs == null || inputs.length == 0 || inputs[0] == null) {\n            this.isFulFilled = true;\n            console.debug(`buffered: ${(this._waves[0].byteLength / 1024 / 1024).toFixed(2)}MB`);\n        }\n        else {\n            const k = Math.min(inputs.length, this._waves.length);\n            for (let i = 0; i < k; i++) {\n                this._waves[i].write(inputs[i]);\n            }\n        }\n    }\n    _processImpl(channels) {\n        const k = Math.min(channels.length, this._waves.length);\n        for (let i = 0; i < k; i++) {\n            this._waves[i].process(channels[i]);\n        }\n        if (this.isFulFilled && this._waves[0].rp == this._waves[0].wp) {\n            return false;\n        }\n        return true;\n    }\n    onAudioProcess(ev) {\n        const channels = [];\n        for (let i = 0; i < ev.outputBuffer.numberOfChannels; i++) {\n            channels.push(ev.outputBuffer.getChannelData(i));\n        }\n        return this._processImpl(channels);\n    }\n    onAudioWorkletProcess(inputs, outputs) {\n        const channels = outputs[0];\n        return this._processImpl(channels);\n    }\n}\n\n\n//# sourceURL=webpack://kss-worklet/./node_modules/webaudio-stream-player/dist/wave-buffer.js?");

/***/ }),

/***/ "./node_modules/webaudio-stream-player/dist/workers/audio-decoder-worker.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/webaudio-stream-player/dist/workers/audio-decoder-worker.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioDecoderWorker\": () => (/* binding */ AudioDecoderWorker)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass InternalProcessor {\n    constructor(id, process) {\n        this.aborted = false;\n        this._completer = null;\n        this.id = id;\n        this._process = process;\n    }\n    abort() {\n        this.aborted = true;\n        return this._completer;\n    }\n    run() {\n        this._completer = new Promise((resolve) => {\n            const res = this._process(this);\n            resolve(res);\n        });\n        return this._completer;\n    }\n}\nclass AudioDecoderWorker {\n    constructor(worker) {\n        this._outputPort = null;\n        this._processorId = 0;\n        this._processor = null;\n        this._sampleRate = 44100;\n        this._numberOfChannels = 2;\n        this._worker = worker;\n        this._worker.onmessage = (e) => __awaiter(this, void 0, void 0, function* () {\n            let res;\n            const req = e.data;\n            try {\n                const data = yield this._onRequest(req);\n                res = { seq: req.seq, type: req.type, data: data };\n            }\n            catch (e) {\n                res = { seq: req.seq, type: req.type, error: e };\n            }\n            this._worker.postMessage(res);\n        });\n    }\n    _detachPort() {\n        var _a;\n        if (this._outputPort != null) {\n            this._outputPort.onmessage = null;\n            (_a = this._outputPort) === null || _a === void 0 ? void 0 : _a.close();\n            this._outputPort = null;\n        }\n    }\n    get sampleRate() { return this._sampleRate; }\n    get numberOfChannels() { return this._numberOfChannels; }\n    _onRequest(req) {\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (req.type) {\n                case 'init':\n                    this._sampleRate = req.args.sampleRate;\n                    this._numberOfChannels = req.args.numberOfChannels;\n                    yield this.init(req.args);\n                    break;\n                case 'start':\n                    if (this._processor != null) {\n                        throw new Error(`Already started.`);\n                    }\n                    this._outputPort = req.outputPort;\n                    yield this.start(req.args);\n                    this._run();\n                    return;\n                case 'abort':\n                    yield this._abort();\n                    yield this.abort();\n                    this._detachPort();\n                    return;\n                case 'dispose':\n                    yield this._abort();\n                    yield this.dispose();\n                    this._detachPort();\n                    return;\n                default:\n                    throw new Error(`Uknown request type: ${req.type}`);\n            }\n        });\n    }\n    _dispatchProgress(elapsed, decodeFrames, isDecoding) {\n        const decodeSpeed = elapsed != 0 ? (decodeFrames / this.sampleRate * 1000) / elapsed : 0;\n        this._worker.postMessage({\n            type: 'progress', data: {\n                decodeFrames,\n                decodeSpeed,\n                isDecoding,\n            }\n        });\n    }\n    _run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const start = Date.now();\n            let decodeFrames = 0;\n            this._processor = new InternalProcessor(this._processorId++, (parent) => __awaiter(this, void 0, void 0, function* () {\n                var _a, _b;\n                while (!parent.aborted) {\n                    const channels = yield this.process();\n                    if (channels != null) {\n                        decodeFrames += channels[0].length;\n                        const transfer = channels.map((e) => e.buffer);\n                        (_a = this._outputPort) === null || _a === void 0 ? void 0 : _a.postMessage(channels, transfer);\n                    }\n                    else {\n                        (_b = this._outputPort) === null || _b === void 0 ? void 0 : _b.postMessage(null);\n                        break;\n                    }\n                    this._dispatchProgress(Date.now() - start, decodeFrames, true);\n                    yield new Promise((resolve) => setTimeout(resolve, 0));\n                }\n            }));\n            yield this._processor.run();\n            this._dispatchProgress(Date.now() - start, decodeFrames, false);\n            this._processor = null;\n        });\n    }\n    _abort() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._processor != null) {\n                const id = this._processor.id;\n                yield this._processor.abort();\n                this._processor = null;\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://kss-worklet/./node_modules/webaudio-stream-player/dist/workers/audio-decoder-worker.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/******/ // expose the modules object (__webpack_modules__)
/******/ __webpack_require__.m = __webpack_modules__;
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/get javascript chunk filename */
/******/ (() => {
/******/ 	// This function allow to reference async chunks
/******/ 	__webpack_require__.u = (chunkId) => {
/******/ 		// return url for filenames based on template
/******/ 		return "" + chunkId + ".js";
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/publicPath */
/******/ (() => {
/******/ 	__webpack_require__.p = "/js/";
/******/ })();
/******/ 
/******/ /* webpack/runtime/jsonp chunk loading */
/******/ (() => {
/******/ 	__webpack_require__.b = document.baseURI || self.location.href;
/******/ 	
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"index": 0
/******/ 	};
/******/ 	
/******/ 	// no chunk on demand loading
/******/ 	
/******/ 	// no prefetching
/******/ 	
/******/ 	// no preloaded
/******/ 	
/******/ 	// no HMR
/******/ 	
/******/ 	// no HMR manifest
/******/ 	
/******/ 	// no on chunks loaded
/******/ 	
/******/ 	// no jsonp function
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ var __webpack_exports__abort = __webpack_exports__.abort;
/******/ var __webpack_exports__analyser = __webpack_exports__.analyser;
/******/ var __webpack_exports__audioContext = __webpack_exports__.audioContext;
/******/ var __webpack_exports__fwd = __webpack_exports__.fwd;
/******/ var __webpack_exports__load = __webpack_exports__.load;
/******/ var __webpack_exports__main = __webpack_exports__.main;
/******/ var __webpack_exports__next = __webpack_exports__.next;
/******/ var __webpack_exports__pause = __webpack_exports__.pause;
/******/ var __webpack_exports__play = __webpack_exports__.play;
/******/ var __webpack_exports__prev = __webpack_exports__.prev;
/******/ var __webpack_exports__replay = __webpack_exports__.replay;
/******/ var __webpack_exports__resume = __webpack_exports__.resume;
/******/ var __webpack_exports__resumeAudioContext = __webpack_exports__.resumeAudioContext;
/******/ var __webpack_exports__rev = __webpack_exports__.rev;
/******/ export { __webpack_exports__abort as abort, __webpack_exports__analyser as analyser, __webpack_exports__audioContext as audioContext, __webpack_exports__fwd as fwd, __webpack_exports__load as load, __webpack_exports__main as main, __webpack_exports__next as next, __webpack_exports__pause as pause, __webpack_exports__play as play, __webpack_exports__prev as prev, __webpack_exports__replay as replay, __webpack_exports__resume as resume, __webpack_exports__resumeAudioContext as resumeAudioContext, __webpack_exports__rev as rev };
/******/ 
